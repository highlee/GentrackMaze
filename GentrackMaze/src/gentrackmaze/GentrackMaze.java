/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gentrackmaze;

import java.awt.FileDialog;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.prefs.Preferences;
import javax.swing.JFileChooser;
import javax.swing.UIManager;

/**
 *
 * @author Z
 */
public class GentrackMaze extends javax.swing.JFrame {

    int rows = 0;
    int cols = 0;
    int startX = 0;
    int startY = 0;
    int endX = 0;
    int endY = 0;
    int[][] maze;
    int[][] move = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    final int PATH = 0;
    final int WALL = 1;
    final int WALKED = -1;

    /**
     * Creates new form GentrackMaze
     */
    public GentrackMaze() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnSelectMaze = new javax.swing.JButton();
        lblFileName = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        taMazeAnswer = new javax.swing.JTextArea();
        btnSolve = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        btnSelectMaze.setText("Select Maze File");
        btnSelectMaze.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSelectMazeActionPerformed(evt);
            }
        });

        lblFileName.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        lblFileName.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        taMazeAnswer.setColumns(20);
        taMazeAnswer.setRows(5);
        jScrollPane1.setViewportView(taMazeAnswer);

        btnSolve.setText("Solve Maze");
        btnSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSolveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(292, 292, 292)
                        .addComponent(lblFileName, javax.swing.GroupLayout.PREFERRED_SIZE, 320, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(388, 388, 388)
                        .addComponent(btnSelectMaze))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(400, 400, 400)
                        .addComponent(btnSolve)))
                .addContainerGap(328, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(lblFileName, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnSelectMaze)
                .addGap(50, 50, 50)
                .addComponent(btnSolve)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 475, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSelectMazeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSelectMazeActionPerformed
        selectMazeFile();
    }//GEN-LAST:event_btnSelectMazeActionPerformed

    private void btnSolveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSolveActionPerformed
        solveMaze();
    }//GEN-LAST:event_btnSolveActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
//        try {
//            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
//                if ("Nimbus".equals(info.getName())) {
//                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
//                    break;
//                }
//            }
//        } catch (ClassNotFoundException ex) {
//            java.util.logging.Logger.getLogger(GentrackMaze.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (InstantiationException ex) {
//            java.util.logging.Logger.getLogger(GentrackMaze.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (IllegalAccessException ex) {
//            java.util.logging.Logger.getLogger(GentrackMaze.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
//            java.util.logging.Logger.getLogger(GentrackMaze.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        }

        String lookAndFeel = UIManager.getSystemLookAndFeelClassName();
        try {
            UIManager.setLookAndFeel(lookAndFeel);
        } catch (Exception ex) {
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GentrackMaze().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnSelectMaze;
    private javax.swing.JButton btnSolve;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblFileName;
    private javax.swing.JTextArea taMazeAnswer;
    // End of variables declaration//GEN-END:variables

    private void selectMazeFile() {
        taMazeAnswer.setText("");
        Preferences prefs = Preferences.userRoot().node(getClass().getName());
        JFileChooser fc = new JFileChooser(prefs.get("LAST_USED_FOLDER",
                new File(".").getAbsolutePath()));
        fc.setDialogType(FileDialog.LOAD);
        fc.setAcceptAllFileFilterUsed(false);
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        fc.setFileFilter(new javax.swing.filechooser.FileFilter() {
            @Override
            public boolean accept(File f) {
                if (f.isDirectory()) {
                    return true;
                } else {
                    return (f.getName().toLowerCase().endsWith(".txt"));
                }
            }

            @Override
            public String getDescription() {
                return "Text Document (*.txt)";
            }
        });

        int returnVal = fc.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // do something
            prefs.put("LAST_USED_FOLDER", fc.getSelectedFile().getPath());
            File f = fc.getSelectedFile();
            initMaze(f);
        } else {
            lblFileName.setText("");
        }

    }

    private void initMaze(File f) {
        lblFileName.setText(f.getName());
        try {
            FileReader reader = new FileReader(f.getPath());
            BufferedReader br = new BufferedReader(reader);
            String line;
            int lineNumber = 0;
            int mazeRow = 0;
            while ((line = br.readLine()) != null) {
                lineNumber++;
                String[] str = line.split(" ");
                if (lineNumber == 1) {
                    //Read rows and cols
                    rows = Integer.valueOf(str[1]);
                    cols = Integer.valueOf(str[0]);
                    maze = new int[rows][cols];
                    System.out.println("rows + cols: " + rows + ":" + cols);
                } else if (lineNumber == 2) {
                    //Read start x and y
                    startX = Integer.valueOf(Integer.valueOf(str[0]));
                    startY = Integer.valueOf(Integer.valueOf(str[1]));
                    System.out.println("startX + startY: " + startX + ":" + startY);
                    taMazeAnswer.append(line + "\n");
                } else if (lineNumber == 3) {
                    //Read end x and y
                    endX = Integer.valueOf(Integer.valueOf(str[0]));
                    endY = Integer.valueOf(Integer.valueOf(str[1]));
                    System.out.println("endX + endY: " + endX + ":" + endY);
                    taMazeAnswer.append(line + "\n");
                } else {
                    //output maze
                    for (int i = 0; i < str.length; i++) {
                        maze[mazeRow][i] = Integer.parseInt(str[i]);
                        System.out.print(Integer.parseInt(str[i]));
                    }
                    System.out.println("");
                    mazeRow++;
                    taMazeAnswer.append(line + "\n");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    private void solveMaze() {
        Stack<Position> stack = new Stack<Position>();
        boolean solved = true;
        int curX = startX;
        int curY = startY;
        maze[curY][curX] = WALKED;
        stack.push(new Position(curY, curX));

        while (!stack.isEmpty() && (!((curX == endX) && (curY == endY)))) {
            int d = 0;
            boolean moved = false;
            while (d < move.length) {
                if ((((curX + move[d][0]) < cols && (curX + move[d][0]) >= 0) && ((curY + move[d][1]) < rows && (curY + move[d][1]) >= 0))) {
                    //Find if the next available path
                    if (maze[curY + move[d][1]][curX + move[d][0]] == PATH) {
                        curX = curX + move[d][0];
                        curY = curY + move[d][1];
                        //Make the move
                        maze[curY][curX] = WALKED;
                        stack.push(new Position(curY, curX));
                        moved = true;
                        break;
                    }
                }
                //change direction 
                d++;
            }
            
            //if all directions checked, and there's no way to go, then check the wrapping
            if ((moved == false) && (d == (move.length))) {
                //Wrapping
                if (curX == 0) {
                    if (maze[curY][maze[curY].length - 1] == PATH) {
                        curX = maze[curY].length - 1;
                        maze[curY][curX] = WALKED;
                        stack.push(new Position(curY, curX));
                        moved = true;
                    }
                } else if (curY == 0) {
                    if (maze[maze.length - 1][curX] == PATH) {
                        curY = maze.length - 1;
                        maze[curY][curX] = WALKED;
                        stack.push(new Position(curY, curX));
                        moved = true;
                    }
                } else if (curX == cols) {
                    if (maze[curY][0] == PATH) {
                        curX = 0;
                        maze[curY][curX] = WALKED;
                        stack.push(new Position(curY, curX));
                        moved = true;
                    }
                } else if (curY == rows) {
                    if (maze[0][curX] == PATH) {
                        curY = 0;
                        maze[curY][curX] = WALKED;
                        stack.push(new Position(curY, curX));
                        moved = true;
                    }
                }
                
                if (moved == false) {
                    //move backward
                    stack.pop();
                    if (stack.empty()) {
                        taMazeAnswer.append("No Solution!");
                        solved = false;
                        break;
                    }
                    curY = stack.peek().row;
                    curX = stack.peek().col;
                }
            }
        }

        if (solved) {
            taMazeAnswer.append("Solution as below:\n");
            while (!stack.empty()) {
                Position p1 = stack.pop();
                maze[p1.row][p1.col] = 2;

            }
            
            //Print answer
            for (int i = 0; i < maze.length; i++) {
                for (int j = 0; j < maze[i].length; j++) {
                    if (i == startY && j == startX) {
                        System.out.print("S");
                        taMazeAnswer.append("S");
                    } else if (i == endY && j == endX) {
                        System.out.print("E");
                        taMazeAnswer.append("E");

                    } else {
                        switch (maze[i][j]) {
                            case -1:
                                taMazeAnswer.append(" ");
                                System.out.print(" ");
                                break;
                            case 0:
                                taMazeAnswer.append(" ");
                                System.out.print(" ");
                                break;
                            case 1:
                                taMazeAnswer.append("#");
                                System.out.print("#");
                                break;
                            case 2:
                                taMazeAnswer.append("X");
                                System.out.print("X");
                                break;
                        }
                    }

                }
                taMazeAnswer.append("\n");
                System.out.println("");
            }
        }

    }
}
